name: CI/CD Pipeline

on:
  push:
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: macos-15
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: '16.0'
    
    - name: Get Package.swift hash
      id: package-hash
      run: |
        if [ -f Package.swift ]; then
          echo "hash=$(shasum -a 256 Package.swift | cut -d' ' -f1)" >> $GITHUB_OUTPUT
        else
          echo "hash=no-package" >> $GITHUB_OUTPUT
        fi
    
    - name: Cache Swift Package Manager
      uses: actions/cache@v4
      with:
        path: .build
        key: ${{ runner.os }}-spm-${{ steps.package-hash.outputs.hash }}
        restore-keys: |
          ${{ runner.os }}-spm-
    
    - name: Build for testing
      run: swift build --configuration debug
    
    - name: Run tests
      run: |
        # Skip tests if no test files exist
        if [ -d "Tests" ] && [ -n "$(find Tests -name '*Tests.swift' 2>/dev/null)" ]; then
          echo "Running tests..."
          swift test --configuration debug --parallel
        else
          echo "âš ï¸ No tests found - skipping test phase"
          echo "Tests can be added later in the Tests/ directory"
        fi
    
    - name: Validate package structure
      run: |
        swift package describe --type json > package-info.json
        cat package-info.json
        
  build:
    needs: test
    runs-on: macos-15
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    outputs:
      app-path: ${{ steps.build.outputs.app-path }}
      version: ${{ steps.version.outputs.version }}
      build-number: ${{ steps.version.outputs.build-number }}
      dmg-path: ${{ steps.dmg.outputs.dmg-path }}
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Setup Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: '16.0'
    
    # ============================================
    # CODE SIGNING SETUP
    # ============================================
    - name: Import signing certificate
      env:
        CERTIFICATE_BASE64: ${{ secrets.DEVELOPER_ID_CERTIFICATE }}
        CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
        KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
      run: |
        # Create temporary keychain
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
        security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
        security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
        security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
        
        # Import certificate
        CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
        echo "$CERTIFICATE_BASE64" | base64 --decode > "$CERTIFICATE_PATH"
        security import "$CERTIFICATE_PATH" \
          -k "$KEYCHAIN_PATH" \
          -P "$CERTIFICATE_PASSWORD" \
          -T /usr/bin/codesign \
          -T /usr/bin/security
        
        # Set key partition list
        security set-key-partition-list \
          -S apple-tool:,apple:,codesign: \
          -s -k "$KEYCHAIN_PASSWORD" \
          "$KEYCHAIN_PATH"
        
        # Add keychain to search list
        security list-keychains -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | sed s/\"//g)
        
        # Verify certificate is available
        security find-identity -v -p codesigning "$KEYCHAIN_PATH"
        
        echo "âœ… Certificate imported successfully"
    
    - name: Get Package.swift hash
      id: package-hash
      run: |
        if [ -f Package.swift ]; then
          echo "hash=$(shasum -a 256 Package.swift | cut -d' ' -f1)" >> $GITHUB_OUTPUT
        else
          echo "hash=no-package" >> $GITHUB_OUTPUT
        fi
    
    - name: Cache Swift Package Manager
      uses: actions/cache@v4
      with:
        path: .build
        key: ${{ runner.os }}-spm-${{ steps.package-hash.outputs.hash }}
        restore-keys: |
          ${{ runner.os }}-spm-
    
    - name: Extract version info
      id: version
      run: |
        if [[ $GITHUB_REF == refs/tags/v* ]]; then
          VERSION=${GITHUB_REF#refs/tags/v}
          BUILD_NUMBER=${{ github.run_number }}
        else
          VERSION="0.1.0-dev"
          BUILD_NUMBER="${{ github.run_number }}"
        fi
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "build-number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
        echo "Version: $VERSION, Build: $BUILD_NUMBER"
    
    - name: Update Info.plist with version
      run: |
        plutil -replace CFBundleShortVersionString -string "${{ steps.version.outputs.version }}" Info.plist
        plutil -replace CFBundleVersion -string "${{ steps.version.outputs.build-number }}" Info.plist
        plutil -p Info.plist
    
    - name: Build release
      id: build
      run: |
        swift build --configuration release --arch arm64 --arch x86_64
        
        # Create app bundle structure
        APP_NAME="MeetingRecorder"
        APP_PATH="dist/Meety.app"
        mkdir -p "$APP_PATH/Contents/MacOS"
        mkdir -p "$APP_PATH/Contents/Resources"
        
        # Copy executable
        cp .build/apple/Products/Release/${APP_NAME} "$APP_PATH/Contents/MacOS/"
        
        # Copy Info.plist
        cp Info.plist "$APP_PATH/Contents/"
        
        # Copy localization bundle (critical for app startup)
        LOCALIZATION_BUNDLE=".build/apple/Products/Release/${APP_NAME}_${APP_NAME}.bundle"
        if [ -d "$LOCALIZATION_BUNDLE" ]; then
          echo "ğŸ“¦ Copying localization bundle: $LOCALIZATION_BUNDLE"
          cp -r "$LOCALIZATION_BUNDLE" "$APP_PATH/Contents/Resources/"
          
          # Copy app icon directly to Resources folder for macOS to find it
          if [ -f "$LOCALIZATION_BUNDLE/AppIcon.icns" ]; then
            cp "$LOCALIZATION_BUNDLE/AppIcon.icns" "$APP_PATH/Contents/Resources/"
            echo "ğŸ¨ App icon copied to Resources/"
          else
            echo "âš ï¸ Warning: AppIcon.icns not found in bundle!"
          fi
        else
          echo "âŒ ERROR: Localization bundle not found at $LOCALIZATION_BUNDLE"
          echo "Available files in build directory:"
          ls -la .build/apple/Products/Release/
          exit 1
        fi
        
        # Copy other resources
        if [ -d "Sources/Resources" ]; then
          cp -r Sources/Resources/* "$APP_PATH/Contents/Resources/"
        fi
        
        echo "app-path=$APP_PATH" >> $GITHUB_OUTPUT
        echo "âœ… App bundle created at: $APP_PATH"
        ls -la "$APP_PATH/Contents/MacOS/"
    
    # ============================================
    # CODE SIGNING WITH DEVELOPER ID
    # ============================================
    - name: Sign application
      env:
        SIGNING_IDENTITY: ${{ secrets.SIGNING_IDENTITY }}
      run: |
        APP_PATH="dist/Meety.app"
        
        echo "ğŸ” Signing application with Developer ID..."
        
        # Sign all dylibs and frameworks first (if any)
        find "$APP_PATH" -type f \( -name "*.dylib" -o -name "*.framework" \) -print0 | while IFS= read -r -d '' file; do
          echo "  Signing: $(basename "$file")"
          codesign --force --sign "$SIGNING_IDENTITY" \
            --timestamp \
            --options runtime \
            "$file" 2>/dev/null || true
        done
        
        # Sign the main executable
        codesign --force --sign "$SIGNING_IDENTITY" \
          --entitlements MeetingRecorder.entitlements \
          --timestamp \
          --options runtime \
          --deep \
          "$APP_PATH/Contents/MacOS/MeetingRecorder"
        
        # Sign the entire app bundle
        codesign --force --sign "$SIGNING_IDENTITY" \
          --entitlements MeetingRecorder.entitlements \
          --timestamp \
          --options runtime \
          --deep \
          "$APP_PATH"
        
        echo "âœ… Application signed successfully"
        
        # Verify signature
        echo "ğŸ” Verifying signature..."
        codesign --verify --deep --strict --verbose=2 "$APP_PATH"
        
        # Display signature info
        echo "ğŸ“‹ Signature details:"
        codesign -dvvv "$APP_PATH" 2>&1 | grep -E "(Authority|TeamIdentifier|Identifier|Format)"
    
    - name: Create DMG
      id: dmg
      env:
        SIGNING_IDENTITY: ${{ secrets.SIGNING_IDENTITY }}
      run: |
        DMG_NAME="Meety-${{ steps.version.outputs.version }}.dmg"
        DMG_PATH="dist/$DMG_NAME"
        
        # Create temporary folder
        mkdir -p dmg-temp
        cp -r "dist/Meety.app" dmg-temp/
        
        # Add installation instructions
        cat > dmg-temp/INSTALLATION.txt << 'EOF'
        ğŸ“¦ Meety Installation
        
        ğŸ”§ Installation Steps:
        1. Drag Meety.app to /Applications folder
        2. Double-click to launch (no security warnings!)
        3. Grant permissions when requested
        
        ğŸ“‹ Required Permissions:
        - Microphone access (for voice recording)
        - Screen recording (for system audio)
        - Documents folder (for saving recordings)
        - Accessibility (for Teams detection)
        
        ğŸš€ Getting Started:
        Look for the microphone icon in your menu bar after launch!
        
        âœ… This app is notarized by Apple and safe to use.
        EOF
        
        # Create symlink to Applications
        ln -s /Applications dmg-temp/Applications
        
        # Create DMG
        hdiutil create -volname "Meety" \
          -srcfolder dmg-temp \
          -ov -format UDZO \
          "$DMG_PATH"
        
        # Clean up temp directory
        rm -rf dmg-temp
        
        # Sign the DMG
        echo "ğŸ” Signing DMG..."
        codesign --force --sign "$SIGNING_IDENTITY" \
          --timestamp \
          "$DMG_PATH"
        
        echo "dmg-path=$DMG_PATH" >> $GITHUB_OUTPUT
        echo "âœ… DMG created and signed: $DMG_NAME"
    
    # ============================================
    # NOTARIZATION
    # ============================================
    - name: Notarize DMG
      env:
        APPLE_ID: ${{ secrets.APPLE_ID }}
        APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
      run: |
        DMG_PATH="dist/Meety-${{ steps.version.outputs.version }}.dmg"
        
        echo "ğŸ“¤ Submitting DMG for notarization..."
        echo "This may take 2-10 minutes..."
        
        # Submit for notarization
        SUBMISSION_OUTPUT=$(xcrun notarytool submit "$DMG_PATH" \
          --apple-id "$APPLE_ID" \
          --team-id "$APPLE_TEAM_ID" \
          --password "$APPLE_APP_PASSWORD" \
          --wait 2>&1)
        
        echo "$SUBMISSION_OUTPUT"
        
        # Extract submission ID
        SUBMISSION_ID=$(echo "$SUBMISSION_OUTPUT" | grep "id:" | head -1 | awk '{print $2}')
        
        if [ -z "$SUBMISSION_ID" ]; then
          echo "âŒ Failed to extract submission ID"
          exit 1
        fi
        
        echo "ğŸ“‹ Submission ID: $SUBMISSION_ID"
        
        # Check if notarization succeeded
        if echo "$SUBMISSION_OUTPUT" | grep -q "status: Accepted"; then
          echo "âœ… Notarization successful!"
        else
          echo "âŒ Notarization failed!"
          echo "Fetching detailed logs..."
          xcrun notarytool log "$SUBMISSION_ID" \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_APP_PASSWORD"
          exit 1
        fi
        
        # Staple the notarization ticket
        echo "ğŸ« Stapling notarization ticket..."
        xcrun stapler staple "$DMG_PATH"
        
        # Validate stapling
        echo "ğŸ” Validating stapled ticket..."
        xcrun stapler validate "$DMG_PATH"
        
        # Test with Gatekeeper
        echo "ğŸ” Testing Gatekeeper assessment..."
        spctl --assess --type install --verbose "$DMG_PATH" || true
        
        echo "âœ… DMG is fully notarized and ready for distribution!"
    
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: Meety-${{ steps.version.outputs.version }}
        path: |
          dist/Meety.app
          dist/Meety-${{ steps.version.outputs.version }}.dmg
    
    - name: Cleanup keychain
      if: always()
      run: |
        KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
        security delete-keychain "$KEYCHAIN_PATH" || true

  release:
    needs: build
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for proper tag detection
    
    - name: Download build artifacts
      uses: actions/download-artifact@v4
      with:
        name: Meety-${{ needs.build.outputs.version }}
        path: release-artifacts/

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        cache: 'pip'

    - name: Install Python dependencies
      run: |
        pip install -r .github/scripts/requirements.txt

    - name: Generate AI-powered release notes
      id: release-notes
      env:
        GOOGLE_API_KEY: ${{ secrets.GOOGLE_API_KEY }}
      run: |
        VERSION="${{ needs.build.outputs.version }}"

        echo "ğŸ¤– Generating release notes with Claude API..."
        python .github/scripts/generate-release-notes.py "v$VERSION" > release-notes.md

        echo "ğŸ“„ Generated release notes:"
        cat release-notes.md

        echo "release-notes-file=release-notes.md" >> $GITHUB_OUTPUT
    
    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        name: "Meety v${{ needs.build.outputs.version }}"
        body_path: release-notes.md
        files: |
          release-artifacts/Meety-${{ needs.build.outputs.version }}.dmg
        draft: false
        prerelease: false
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Post-release summary
      run: |
        echo "ğŸ‰ Release v${{ needs.build.outputs.version }} created!"
        echo "ğŸ“¦ Download: https://github.com/${{ github.repository }}/releases/tag/v${{ needs.build.outputs.version }}"
        echo "âœ… DMG is signed and notarized - users can install with a simple double-click!"
        echo "ğŸ” No security warnings - ready for production distribution"